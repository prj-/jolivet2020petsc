// This codes shows how to calculate the eigenvalue spectrum of
// the Laplace operator on a 2d square domain, using SLEPc.
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-SLEPc.edp \
//        -split 1 -npts 400 -nev 10 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
//load "SLEPc"                             // SLEPc plugin
macro dimension(      )3// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

load "Element_P3"
load "qf11to25"
func Pk = P3;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , pi)  ; // Dimension of the domain
real Ly    = getARGV("-ly"   , pi)  ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
meshN Th = cube(1, 1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] LL = [1,2, 1,2, 1,1];

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain

    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
func bool channel(real a, real b, real dx1, real dy1, real dx2, real dy2, real width) {
    real slope = (dy2 - dy1) / (dx2 - dx1);
    if(a >= dx1 && a <= dx2) {
        if(b >= (slope * (x - dx2) + dy2) && b <= (slope * (x - dx2) + dy2 + width))
            return true;
    }
    return false;
}
func real skyscraper(real a, real b) {
    int da = int(9 * a);
    int db = int(9 * b);
    real kappa;
    if((da + 1) % 2 && (db + 1) % 2)
        kappa = 1e+1 * real(da + db + 1);
    else {
        if(channel(a, b, 0.1, 0.2, 0.5, 0.6, 0.15))
            kappa = b * 1e+1;
        else if(channel(a, b, 0.5, 0.15, 0.9, 0.05, 0.2))
            kappa = a * 1e+1;
        else if(channel(a, b, 0.3, 0.6, 0.9, 0.5, 0.2))
            kappa = (a + b) * 1e+1;
        else
            kappa = 1;
    }
    return kappa;
}
varf vA(uh,vh)= intN(Th)        //  Definion of  the problem
( skyscraper(x,y)*(dx(uh)*dx(vh)+dy(uh)*dy(vh)+dz(uh)*dz(vh))
    )//  Bilinear form
    +on(1,2, uh = 0.0)    //  Boundary Conditions
    +intN(Th)(vh)
;

varf vB(uh,vh)= intN(Th,qfV=qfVp6)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh,tgv=-2);
matrix<real> B = vB(Vh,Vh,tgv=-20);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);//, clean = true);
Mat DistB(DistA, B, clean = true);
// set(DistA, sparams = " -pc_type hypre");
// set(DistA, sparams = "-ksp_type hpddm -ksp_rtol 1e-8 -ksp_max_it 5 -pc_type hypre");
// set(DistA, sparams = "-ksp_type hpddm -ksp_rtol 1e-8 -ksp_max_it 5 -pc_type asm -sub_pc_type cholesky -sub_pc_factor_mat_solver_type mumps ");
// set(DistA, sparams = "-ksp_type gmres -ksp_mat_solve_blocksize 1 -ksp_rtol 1e-8 -pc_hpddm_levels_1_pc_type asm -pc_hpddm_has_neumann true -pc_hpddm_define_subdomains true " + " -ksp_max_it 5 -pc_type hpddm -pc_hpddm_levels_1_eps_nev 20 -pc_hpddm_levels_1_ksp_type hpddm -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_levels_1_sub_pc_factor_mat_solver_type mumps " + "  -pc_hpddm_coarse_pc_type cholesky -pc_hpddm_coarse_ksp_monitor -pc_hpddm_coarse_ksp_hpddm_type gmres -pc_hpddm_coarse_ksp_type hpddm -pc_hpddm_coarse_pc_factor_mat_solver_type mumps -pc_hpddm_levels_1_st_pc_factor_mat_solver_type mumps");
// set(DistA, sparams = "-ksp_type hpddm -ksp_rtol 1e-8  -ksp_max_it 5 -pc_type asm -sub_pc_factor_mat_solver_type mumps " + "  -sub_pc_type cholesky");
set(DistA, sparams = "-ksp_type hpddm -ksp_hpddm_type gmres -ksp_rtol 1e-8 -pc_hpddm_has_neumann -pc_hpddm_define_subdomains" + " -ksp_max_it 5 -pc_type hpddm -pc_hpddm_levels_1_eps_nev 15 -pc_hpddm_levels_1_sub_pc_type cholesky -pc_hpddm_levels_1_sub_pc_factor_mat_solver_type mumps " + " -pc_hpddm_coarse_p 24 -pc_hpddm_coarse_pc_type cholesky -pc_hpddm_coarse_ksp_monitor -pc_hpddm_coarse_pc_factor_mat_solver_type mumps -pc_hpddm_levels_1_st_pc_factor_mat_solver_type mumps " + "  -pc_hpddm_levels_1_st_pc_type cholesky ");
// real[int] rhs = vA(0,Vh,tgv=-2);
// real[int] sol = DistA^-1 * rhs;
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1);  // array to store eigenvectors
string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  // " -eps_target 0 -eps_target_magnitude" +
  // " -st_type sinvert " +
  " -eps_type lobpcg" +
  " -st_type precond "     +
  // " -st_pc_type gamg -st_ksp_type hpddm -st_ksp_hpddm_type gmres  -st_ksp_rtol 1e-8 -st_ksp_max_it 5"       +
  // " -st_pc_gamg_threshold 0.01 -st_mg_levels_ksp_type chebyshev -st_mg_levels_esteig_ksp_type cg"       +
  // " -st_pc_type hypre"       +
  // " -st_pc_hypre_boomeramg_strong_threshold 0.45 "       +
  // " -st_pc_hypre_boomeramg_agg_nl 7  -st_pc_hypre_boomeramg_print_statistics 1"       +
  " -bv_orthog_block svqb -bv_type contiguous " +
   "  -eps_lobpcg_blocksize 40 " +
  // " -st_pc_type hpddm -st_pc_hpddm_levels_1_eps_nev 5 -st_pc_hpddm_levels_1_sub_pc_type lu "       +
  // " -st_pc_type asm -st_sub_pc_type lu "       +
  " -eps_view "+
  " -eps_gen_hermitian"
  ;

int k = EPSSolve
(DistA,              // matrix OP = A âˆ’ sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    int[int] fforder(1);
    fforder = [1];
    savevtk("eigenvalue.vtu", Th, EigenVEC[i], order = fforder, append = i ? true : false);
}
